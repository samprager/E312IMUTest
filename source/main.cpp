/*
  File Name: main.cpp
  Description: IMU data extraction for USRP E310/E312
  Author: Samuel Prager
  Email: sprager@usc.edu
  Created: January 1 2018
  Copyright 2012-2019 Samuel Prager
*/

#include <iostream>
#include <string>
#include <iterator>
#include <fstream>
#include <streambuf>
#include <vector>
#include <csignal>
#include <sys/types.h>
#include <sys/time.h>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <boost/format.hpp>
#include <boost/thread.hpp>
#include <boost/date_time.hpp>

#include "RTIMULib.h"

#define IMU_LOG_INTERVAL 1000 // imu log interval in microseconds

static bool stop_signal_called = false;
void sig_int_handler(int)
{
    stop_signal_called = true;
}

RTIMU *_imu;
RTIMU_DATA _imuData;

int imu_init(){
  // These aren't used here, but were probably included in an example from RTIMULIb...
  // I'll keep them around for now in case they provide hints moving forward
  int sampleCount = 0;
  int sampleRate = 0;
  uint64_t rateTimer;
  uint64_t displayTimer;
  uint64_t now;

  //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  //  Or, you can create the .ini in some other directory by using:
  //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
  //  where <directory path> is the path to where the .ini file is to be loaded/saved

  // RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
  RTIMUSettings *settings = new RTIMUSettings("/etc","RTIMULib");


  _imu = RTIMU::createIMU(settings);

  if ((_imu == NULL) || (_imu->IMUType() == RTIMU_TYPE_NULL)) {
      std::cerr<<"No IMU found\n";
      return 1;
  }
  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU

  _imu->IMUInit();

  //  this is a convenient place to change fusion parameters
  _imu->setSlerpPower(0.02);
  _imu->setGyroEnable(true);
  _imu->setAccelEnable(true);
  _imu->setCompassEnable(true);

  _imu->IMURead();
  _imuData = _imu->getIMUData();

  return 0;
}

std::string get_imu_data(const std::string &type){
    std::stringstream imuss;
    if (type=="fusion"){
      imuss << boost::format("(roll:%+09.4f,pitch:%+08.4f,yaw:%+09.4f)") % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.x()) % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.y()) % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.z());
    }
    else if (type =="accel"){
      imuss << boost::format("(%+08.4f,%+08.4f,%+08.4f)") % (10*_imuData.accel.x())%(10*_imuData.accel.y())%(10*_imuData.accel.z());
    }
    else if (type == "gyro"){
      imuss << boost::format("(%+09.4f,%+09.4f,%+09.4f)") % (RTMATH_RAD_TO_DEGREE*_imuData.gyro.x()) % (RTMATH_RAD_TO_DEGREE*_imuData.gyro.y())%(RTMATH_RAD_TO_DEGREE*_imuData.gyro.z());
    }
    else if (type == "compass"){
      imuss << boost::format("(%+08.4f,%+08.4f,%+08.4f)") % (_imuData.compass.x())%(_imuData.compass.y())%(_imuData.compass.z());
    }
    else if (type == "all") {
        imuss << boost::format("(%+09.4f,%+08.4f,%+09.4f)") % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.x()) % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.y()) % (RTMATH_RAD_TO_DEGREE*_imuData.fusionPose.z());
        imuss << boost::format(" : (%+08.4f,%+08.4f,%+08.4f)") % (10*_imuData.accel.x())%(10*_imuData.accel.y())%(10*_imuData.accel.z());
        imuss << boost::format(" : (%+09.4f,%+09.4f,%+09.4f)") % (RTMATH_RAD_TO_DEGREE*_imuData.gyro.x()) % (RTMATH_RAD_TO_DEGREE*_imuData.gyro.y())%(RTMATH_RAD_TO_DEGREE*_imuData.gyro.z());
        imuss << boost::format(" : (%+08.4f,%+08.4f,%+08.4f)") % (_imuData.compass.x())%(_imuData.compass.y())%(_imuData.compass.z());
    }
    else{
        imuss<<"[get_imu_data] Error: Unrecognized option";
    }
    return imuss.str();
}

int main(int argc, char *argv[])
{

    std::string example_option,filename;
    unsigned long update_interval;
    bool printonly;

    //setup the program options
    boost::program_options::options_description desc("Allowed options");
    desc.add_options()
        ("help", "help message")
        ("example_option", boost::program_options::value<std::string>(&example_option)->default_value("for example"), "this is an example option")
        ("interval", boost::program_options::value<unsigned long>(&update_interval)->default_value(IMU_LOG_INTERVAL), "IMU update interval in microseconds")
        ("file", boost::program_options::value<std::string>(&filename), "Output file name (will be in ~/.E312IMUTest/)")
        ("printonly", boost::program_options::value<bool>(&printonly)->default_value(false), "Only print data to screen")
    ;
    boost::program_options::variables_map vm;
    boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), vm);
    boost::program_options::notify(vm);

    //print the help message
    if (vm.count("help")){
        std::cout
            << boost::format("E312IMUTest - write IMU data to a log file  %s.") % desc
            << std::endl;
        return ~0;
    }

    if (vm.count("example_option") > 0) {
        std::cout<<"Do something here with example option input: "<<example_option<<std::endl;
    }

    boost::filesystem::path out_path;
    const char * home = getenv ("HOME");
    if (home == NULL) {
      out_path = boost::filesystem::system_complete(argv[0]).parent_path().parent_path().parent_path();
      std::cerr << "error: Env HOME variable not set. Using " <<out_path.string()<< std::endl;
     //  throw std::invalid_argument ("error: HOME environment variable not set.");
    }
    else{
        out_path = boost::filesystem::path(std::string(home)) / boost::filesystem::path(".E312IMUTest");
        if (!boost::filesystem::exists(out_path)) boost::filesystem::create_directory(out_path);
    }

    //Setup IMU
    int err = imu_init();
    if (err){
      std::cerr<<"Error intializing IMU"<<std::endl;
      return 1;
    }

    bool imu_log = not printonly;
    uint64_t now, logtimer;

    boost::filesystem::path imu_logfile;

    if (vm.count("file")){
        imu_logfile = out_path / boost::filesystem::path(filename);
    }
    else{
        imu_logfile = out_path / boost::filesystem::path("imu_data.log");
    }
    std::ofstream outfile(imu_logfile.c_str(),std::ios_base::out | std::ios_base::app);
    outfile <<"\nTimestamp : Log Time : Fusion(roll,pitch,yaw) : Accel(x,y,z) : Gyro(x,y,z) : Compass(x,y,z)\n"<<std::endl;
    logtimer = 0;//RTMath::currentUSecsSinceEpoch();

    std::signal(SIGINT, &sig_int_handler);
    std::cout << "Press Ctrl + C to stop streaming..." << std::endl;

    while (!stop_signal_called){
      usleep(_imu->IMUGetPollInterval() * 1000); // this should be in usec? check to confirm IMUGetPollInterval() return value
      while (_imu->IMURead()) {
        _imuData = _imu->getIMUData();
        now = RTMath::currentUSecsSinceEpoch();
        if ((now-logtimer)>update_interval){
            std::stringstream ss;
            std::string timestamp = to_iso_string(boost::posix_time::microsec_clock::local_time());
            std::string logtimestr = std::to_string(now);
            ss << timestamp<<" : "<<logtimestr<<" : "<<get_imu_data("all");
            if(imu_log){
              ss <<"\n";
              outfile << ss.str();
              //outfile.flush();
            }
            else{
                std::cout<<ss<<"\r"<<std::flush;
            }
            logtimer = now;
        }
      }
    }
    outfile.close();
    return 0;
}
